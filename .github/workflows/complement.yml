name: Complement Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  complement:
    name: Run Complement Compliance Tests
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    timeout-minutes: 60
    env:
      # Give Complement more time to spawn the homeserver in CI
      COMPLEMENT_SPAWN_HS_TIMEOUT_SECS: "300"
      # Force Complement to use the loopback host IP for port binding lookups
      HSPortBindingIP: "127.0.0.1"
    
    steps:
    - name: Checkout FERRETCANNON
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build Complement Docker Image
      run: |
        docker build -t complement-ferretcannon:latest -f Complement.Dockerfile .
        
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'
        cache: false
        
    - name: Checkout Complement
      uses: actions/checkout@v4
      with:
        repository: matrix-org/complement
        path: complement-checkout
        
    - name: Run Complement Tests
      working-directory: complement-checkout
      env:
        COMPLEMENT_BASE_IMAGE: complement-ferretcannon:latest
        NO_COLOR: "1"
        TERM: dumb
        COMPLEMENT_SPAWN_HS_TIMEOUT_SECS: "300"
      run: |
        go test -v -timeout 45m -json ./tests/... 2>&1 | tee complement-output.json || true
      continue-on-error: true
      
    - name: Parse Test Results
      if: always()
      run: |
        cd complement-checkout || exit 0

        # Check if output file exists
        if [ ! -f complement-output.json ]; then
          echo "## Complement Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "⚠️ No test output file found. Tests may not have run." >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        # Use jq to parse JSON output and compute per-test final actions.
        # go test -json emits multiple events per test; group by .Test and
        # take the last event to determine the final Action for each test.
        echo "## Complement Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Install jq on the runner
        sudo apt-get update && sudo apt-get install -y jq

        # Read line-delimited output but ignore non-JSON lines (some runners or tools
        # may interleave non-JSON text). Use fromjson with catch to skip invalid lines.
        PASSED=$(jq -R -s 'split("\n") | map(try fromjson catch null) | map(select(.!=null and .Test != null)) | group_by(.Test) | map(.[-1]) | map(select(.Action=="pass")) | length' complement-output.json)
        FAILED=$(jq -R -s 'split("\n") | map(try fromjson catch null) | map(select(.!=null and .Test != null)) | group_by(.Test) | map(.[-1]) | map(select(.Action=="fail")) | length' complement-output.json)
        SKIPPED=$(jq -R -s 'split("\n") | map(try fromjson catch null) | map(select(.!=null and .Test != null)) | group_by(.Test) | map(.[-1]) | map(select(.Action=="skip")) | length' complement-output.json)

        echo "✅ **Passed**: $PASSED" >> $GITHUB_STEP_SUMMARY
        echo "❌ **Failed**: $FAILED" >> $GITHUB_STEP_SUMMARY
        echo "⏭️ **Skipped**: $SKIPPED" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ "$FAILED" -gt 0 ]; then
          echo "### Failed Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          jq -R -s 'split("\n") | map(try fromjson catch null) | map(select(.!=null and .Test != null)) | group_by(.Test) | map(.[-1]) | .[] | select(.Action=="fail") | .Test' complement-output.json \
            | sed 's/^"//;s/"$//' | sort -u | while read test; do
              echo "- ❌ $test" >> $GITHUB_STEP_SUMMARY
            done
        fi
      
    - name: Produce compact JSON summary
      if: always()
      working-directory: complement-checkout
      run: |
        sudo apt-get update && sudo apt-get install -y jq
        chmod +x ../scripts/summarize_complement.sh
        ../scripts/summarize_complement.sh .

    - name: Upload compact summary
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: complement-summary
        path: |
          complement-checkout/complement-summary.json
          complement-checkout/complement-summary.txt
        retention-days: 30
        if-no-files-found: ignore

    - name: Append human summary to job summary
      if: always()
      working-directory: complement-checkout
      run: |
        if [ -f complement-summary.txt ]; then
          echo "## Complement Summary" >> $GITHUB_STEP_SUMMARY
          echo '' >> $GITHUB_STEP_SUMMARY
          sed -n '1,200p' complement-summary.txt >> $GITHUB_STEP_SUMMARY
        fi

    - name: Compare with previous run summary and post delta
      if: always()
      working-directory: complement-checkout
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        REPO: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
        EVENT_NAME: ${{ github.event_name }}
        PR_NUMBER: ${{ github.event.pull_request.number || '' }}
      run: |
        set -euo pipefail
        sudo apt-get update && sudo apt-get install -y jq unzip curl

        # Determine branch name (works for push and PR events)
        BRANCH="${{ github.ref_name }}"

        echo "Looking for previous complement workflow runs for branch: $BRANCH"

        # Find previous completed run for the complement workflow (exclude current run)
        runs_url="https://api.github.com/repos/$REPO/actions/workflows/complement.yml/runs?per_page=10&branch=$BRANCH"
        prev_run_id=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$runs_url" \
          | jq -r --argjson cur $RUN_ID '.workflow_runs[] | select(.id != ($cur|tonumber) and .conclusion != null) | .id' | head -n1)

        if [ -z "$prev_run_id" ]; then
          echo "No previous completed run found; skipping delta computation.";
          exit 0
        fi

        echo "Found previous run id: $prev_run_id"

        # Get artifacts for previous run
        artifacts_url="https://api.github.com/repos/$REPO/actions/runs/$prev_run_id/artifacts"
        artifact_info=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$artifacts_url")

        artifact_id=$(echo "$artifact_info" | jq -r '.artifacts[] | select(.name=="complement-summary") | .id' || true)
        if [ -z "$artifact_id" ] || [ "$artifact_id" = "null" ]; then
          echo "No complement-summary artifact found for previous run; skipping delta computation.";
          exit 0
        fi

        echo "Found artifact id: $artifact_id; downloading..."

        download_url="https://api.github.com/repos/$REPO/actions/artifacts/$artifact_id/zip"
        curl -s -L -H "Authorization: token $GITHUB_TOKEN" -o prev_artifact.zip "$download_url"
        unzip -o prev_artifact.zip -d prev_artifact

        if [ ! -f prev_artifact/complement-summary.json ]; then
          echo "previous summary missing; skipping";
          exit 0
        fi

        # Compare previous summary with current
        if [ ! -f complement-summary.json ]; then
          echo "current summary missing; skipping";
          exit 0
        fi

        jq -s '{prev: .[0], curr: .[1]} | {
          prev_counts: {pass: .prev.pass, fail: .prev.fail, skip: .prev.skip},
          curr_counts: {pass: .curr.pass, fail: .curr.fail, skip: .curr.skip},
          newly_failed: (.curr.failed_tests - .prev.failed_tests),
          newly_fixed: (.prev.failed_tests - .curr.failed_tests)
        }' prev_artifact/complement-summary.json complement-summary.json > complement-delta.json

        echo "Delta written to complement-delta.json"

        # Append human delta to job summary
        echo "## Complement Delta vs previous run" >> $GITHUB_STEP_SUMMARY
        echo '' >> $GITHUB_STEP_SUMMARY
        jq -r '"Previous: pass=\(.prev_counts.pass) fail=\(.prev_counts.fail) skip=\(.prev_counts.skip)\nCurrent: pass=\(.curr_counts.pass) fail=\(.curr_counts.fail) skip=\(.curr_counts.skip)\n\nNew failures:\n" + ( .newly_failed | map("- " + .) | join("\n") ) + "\n\nNewly fixed:\n" + ( .newly_fixed | map("- " + .) | join("\n") )' complement-delta.json >> $GITHUB_STEP_SUMMARY

        # Optionally post PR comment when running on a pull_request
        if [ "$EVENT_NAME" = "pull_request" ] && [ -n "$PR_NUMBER" ]; then
          echo "Posting delta comment to PR #$PR_NUMBER"
          body=$(jq -r '"### Complement delta\n\nPrevious: pass=\(.prev_counts.pass) fail=\(.prev_counts.fail) skip=\(.prev_counts.skip)\nCurrent: pass=\(.curr_counts.pass) fail=\(.curr_counts.fail) skip=\(.curr_counts.skip)\n\n**New failures:**\n" + ( .newly_failed | map("- " + .) | join("\n") ) + "\n\n**Newly fixed:**\n" + ( .newly_fixed | map("- " + .) | join("\n") )' complement-delta.json)
          comments_url="https://api.github.com/repos/$REPO/issues/$PR_NUMBER/comments"
          curl -s -H "Authorization: token $GITHUB_TOKEN" -X POST -d "$({ echo -n '{"body":'; jq -Rs . <<<"$body"; echo '}')" "$comments_url" || true
        fi
        
    - name: Upload Test Output
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: complement-results
        path: |
          complement-checkout/complement-output.json
          complement-checkout/*.log
        retention-days: 30
        if-no-files-found: ignore
        
    - name: Check Test Status
      if: always()
      run: |
        cd complement-checkout || exit 0
        
        # Check if output file exists
        if [ ! -f complement-output.json ]; then
          echo "::warning::No test output file found. Tests may not have run."
          exit 0
        fi
        
        FAILED=$(grep -c '"Action":"fail"' complement-output.json 2>/dev/null || echo "0")
        if [ "$FAILED" -gt 0 ]; then
          echo "::warning::$FAILED Complement tests failed"
          # Don't exit 1 - just report the failures
        fi
